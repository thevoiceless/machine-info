#!/usr/bin/env ruby

require 'optparse'
require 'fcntl'
require 'erb'

def exit_display_usage(opts)
	puts opts
	exit 1
end

def exit_if_dir_not_exist(path, args)
	if not File.directory?(path.chomp)
		puts "The given input directory does not exist.\n\n"
		exit_display_usage(args)
	end
end

# Parse and validate command-line arguments
# Python's Argparse is far superior to Ruby's OptionParser, so this gets messy
options = {}
args = OptionParser.new do |opts|
	opts.banner = "Usage: alamode-publish (-s DIRECTORY | Pipe from STDIN) [-d DIRECTORY]"

	opts.on("-s", "--input-dir DIRECTORY", "Directory in which to look for host data files") do |param|
		options[:input_dir] = param
	end

	opts.on("-d", "--output-dir [DIRECTORY]", "Directory in which to save HTML files (defaults to stdout if not given)") do |param|
		options[:output_dir] = param
	end

	opts.on_tail("-h", "--help", "Show this message") do
		puts opts
		exit
	end
end
args.parse!

# Because OptionParser has no built-in way to specify mutually exclusive groups, it has to be done manually
# Set flag if piping from STDIN
options[:input_from_pipe] = (STDIN.fcntl(Fcntl::F_GETFL, 0) == 0)
# Read from STDIN 
if options[:input_from_pipe]
	# Cannot also read from a directory
	if options[:input_dir]
		exit_display_usage(args)
	end
	# Verify that the path is valid
	input_dir_path = STDIN.gets
	exit_if_dir_not_exist(input_dir_path, args)
# Must specify input directory if not reading from STDIN
elsif options[:input_dir]
	input_dir_path = options[:input_dir]
	# Directory must exist
	exit_if_dir_not_exist(input_dir_path, args)
# The user did not specify an input path
else
	exit_display_usage(args)
end

# Check if output directory was given
if options.has_key?(:output_dir)
	# Flag "-d" was given with no argument
	if options[:output_dir].nil?
		exit_display_usage(args)
	# Try to create directory if it doesn't already exist
	else
		begin
			Dir.mkdir(options[:output_dir]) if not File.directory?(options[:output_dir])
		rescue Exception => e
			puts "Error creating directory: #{e}"
			exit 1
		end
	end
	output_dir_path = options[:output_dir]
end

# Finally, the fun stuff
# Get the list of files in the input directory
input_dir_path << '/' unless input_dir_path[-1, 1] == '/'
files = Dir.glob(input_dir_path + "*")
num_files = files.length
# Go through each file
all_info = []
num_cache_levels = 0
for file in files
	machine_info = { :name => File.basename(file) }
	reading_table = false
	File.open(file, "r") do |f|
		# Go through each line and split into (key, value) pairs
		f.each_line do |line|
			# The whole interrupts table is one big value
			if line.strip == "table_interrupt_data"
				reading_table = true
				machine_info[:table_interrupt_data] = ""
			elsif reading_table
				machine_info[:table_interrupt_data] << line
			# Split into two parts based on '='
			else
				num_cache_levels += 1 if line.strip.include?("cache_type")
				words = line.split('=', 2)
				words.map { |x| x.strip! }
				machine_info[words.first.to_sym] = words.last
			end
		end
	end

	# Add this machine's info to the all_info array
	all_info << machine_info
end
erb_html = ERB.new(File.open("results.html.erb").read)
bootstrap_css_path = File.absolute_path("bootstrap.min.css")
index_css_path = File.absolute_path("index.css")
if output_dir_path
	puts "Output to: #{output_dir_path}"
	File.open(output_dir_path.strip << "/index.html", "w") do |f|
		f.write(erb_html.result(binding()))
	end
else
	puts erb_html.result(binding())
end
# puts options