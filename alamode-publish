#!/usr/bin/env ruby

require 'optparse'
require 'fcntl'

def exit_display_usage(opts)
	puts opts
	exit 1
end

# Parse command-line arguments
# Python's Argparse is far superior to Ruby's OptionParser, so this gets messy
options = {}
args = OptionParser.new do |opts|
	opts.banner = "Usage: alamode-publish (-s DIRECTORY | Pipe from STDIN) [-d DIRECTORY]"

	opts.on("-s", "--input-dir DIRECTORY", "Directory in which to look for host data files") do |param|
		options[:input_dir] = param
	end

	opts.on("-d", "--output-dir [DIRECTORY]", "Directory in which to save HTML files (defaults to stdout if not given)") do |param|
		options[:output_dir] = param
	end

	opts.on_tail("-h", "--help", "Show this message") do
		puts opts
		exit
	end
end
args.parse!
# Set flag if piping from STDIN
options[:input_from_pipe] = (STDIN.fcntl(Fcntl::F_GETFL, 0) == 0)
# Either read from STDIN or a given directory
if options[:input_from_pipe]
	# Cannot accept both
	if options[:input_dir]
		exit_display_usage(args)
	end
# Must specify input directory if not reading from STDIN
elsif not options[:input_dir]
	exit_display_usage(args)
# Input directory must exist
elsif not File.directory?(options[:input_dir])
	puts "The given input directory does not exist."
	exit_display_usage(args)
end
# Check if output directory was given
if options.has_key?(:output_dir)
	# Flag was given with no argument
	if options[:output_dir].nil?
		exit_display_usage(args)
	# Try to create directory if it doesn't already exist
	else
		begin
			Dir.mkdir(options[:output_dir])
		rescue Exception => e
			puts "Error creating directory: #{e}"
			exit 1
		end
	end
end

if options[:input_from_pipe]
	puts "foo"
else
	puts "bar"
end

p options